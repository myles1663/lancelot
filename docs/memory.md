# Memory System

How Lancelot remembers — a tiered memory architecture with commit-based editing, quarantine for risky writes, and deterministic context compilation.

For how memory fits into the overall architecture, see [Architecture](architecture.md). For memory security specifics, see [Security Posture](security.md).

---

## Why Not Just RAG?

Most AI agents use vector search to "remember" things. They embed text, store it in a vector database, and retrieve the most similar chunks when needed. This is lossy — the agent's behavior depends on which chunks similarity search happens to return, and the results vary with embedding quality, chunk size, and query phrasing.

Lancelot takes a different approach: **deterministic, structured memory** with explicit tiers, governed edits, and a context compiler that assembles exactly the same prompt given the same inputs. You know what the model sees, and it's the same every time.

---

## The Four Tiers

Memory is organized into four tiers with different persistence, access patterns, and security properties.

### Tier A — Core Memory (Pinned Blocks)

**Always included in context.** These blocks appear in every prompt, in a fixed order.

| Block | Description | Example |
|-------|-------------|---------|
| `persona` | Derived from Soul — behavioral identity | "Lancelot is a governed autonomous system..." |
| `human` | Owner preferences and profile | Loaded from `USER.md` + verified facts |
| `mission` | Long-running objectives, current quest focus | "Content repurposing pipeline for client X" |
| `operating_rules` | Execution style constraints, guardrails | "Never commit secrets, always verify before delivery" |
| `workspace_state` | Project-specific pinned state | "Working on API v2, branch: feat/connectors" |

**Properties:**
- Small, curated, verified
- Hard token limits per block (enforced by the context compiler)
- Changes require governance — edits to core blocks are quarantined by default
- The `persona` block is derived from the Soul — the agent cannot modify its own identity

### Tier B — Working Memory (Task Scratchpad)

**Short-lived, task-scoped.** Cleared between tasks or after TTL expiry.

Contents:
- Plan scratch (intermediate planning data)
- Extracted facts from current task
- Active TODOs
- Transient decisions

**Properties:**
- Auto-expiring by TTL (hours to days)
- Namespaced by quest/task ID
- The agent can freely write to working memory (T1 governance)
- Lowest priority in context compilation — evicted first when budget is tight

### Tier C — Episodic Memory (Conversation Timeline)

**Session-scoped, append-only.** Captures conversation history and notable events.

Contents:
- Recent messages (or references to chat log)
- Per-session summaries (auto-generated by scheduler job)
- Episodic events (important moments extracted from conversations)

**Properties:**
- Append-only within a session — cannot be retroactively modified
- Periodic summarization compresses old sessions
- Summaries are searchable via the context compiler

### Tier D — Archival Memory (Long-term Store)

**Permanent, searchable knowledge base.** Facts, events, documents, and receipts that persist across sessions.

Contents:
- Verified facts with provenance and confidence scores
- Long-term patterns and learned information
- Document references and summaries
- Historical receipt data

**Properties:**
- Searchable via full-text search (SQLite FTS) and metadata filters
- Entries have confidence scores that decay over time unless reinforced
- Provenance tracking — every entry records where it came from
- Optional TTL for time-sensitive information

---

## Commit-Based Editing

All memory writes follow an atomic commit model. This ensures consistency and enables exact rollback.

### The Commit Workflow

```
memory_begin_edits()           → Creates a staged commit (snapshot taken)
  ↓
memory_insert(...)             → Stage an insertion
memory_replace(...)            → Stage a replacement
memory_delete(...)             → Stage a deletion
  ↓
memory_finish_edits()          → Apply all changes atomically
  OR
memory_rollback()              → Discard all staged changes
```

Each operation in the commit includes:
- **target** — which tier and block
- **content** — the new data
- **reason** — why the edit is being made
- **confidence** — how confident the agent is in this edit (0.0-1.0)
- **provenance** — where the information came from

### Diff Receipts

Every committed edit generates a receipt with a full diff:

```json
{
  "id": "receipt_mem_001",
  "action_type": "memory_edit",
  "commit_id": "commit_abc123",
  "target": "core:mission",
  "diff": {
    "before": "Working on API v2",
    "after": "Working on API v2, branch: feat/connectors"
  },
  "reason": "Updated workspace state after branch switch",
  "confidence": 0.95,
  "provenance": "user_message"
}
```

### Rollback

Rolling back a commit restores the exact prior state:

```
POST /memory/rollback/{commit_id}    (requires Bearer token)
```

Rollback is:
- **Exact** — restores the pre-commit snapshot, not an approximation
- **Idempotent** — rolling back the same commit twice is a safe no-op
- **Receipted** — the rollback itself generates a receipt

You can roll back multiple commits to return to any previous state in the memory history.

---

## Quarantine

Not all memory writes go directly into active memory. Risky writes are placed in **quarantine** — a holding zone where they cannot influence system behavior until explicitly approved.

### What Gets Quarantined

- Edits to core blocks (persona, human, mission, operating_rules)
- Writes with confidence below the configured floor
- Content that triggers security filters (detected injection patterns, secrets)
- Any write the Soul's `memory_ethics` rules flag as sensitive

### Quarantine Workflow

```
Agent proposes memory edit
  → Write gates evaluate the edit
    → If risky → QUARANTINED (visible in War Room, no effect on behavior)
      → Owner reviews → Approve → PROMOTED to active memory
                      → Deny → REJECTED (discarded, receipted)
    → If safe → Committed directly to active memory
```

### Managing the Quarantine Queue

In the War Room Memory panel:

- View all quarantined items with their reason, content, and provenance
- Approve individual items (promotes to active memory)
- Reject individual items (discards with receipt)
- Bulk approve/reject

Via the API:

```
GET  /memory/quarantine                    → List quarantined items
POST /memory/quarantine/{id}/approve       → Approve (requires Bearer token)
POST /memory/quarantine/{id}/reject        → Reject (requires Bearer token)
```

---

## Context Compiler

Before each LLM call, the Context Compiler assembles memory into a token-budgeted prompt. The assembly is **deterministic** — same inputs produce the same compiled context.

### Assembly Algorithm

1. **Compile persona block** from the active Soul
2. **Load Core Blocks** in fixed order: persona → human → operating_rules → mission → workspace_state
3. **Add Working Memory** — quest-namespaced items first, then global, filtered by TTL
4. **Retrieval step** — query archival memory and episodic summaries relevant to the current objective
5. **Budget enforcement** — hard cap per block; if over budget, drop lowest-confidence items first
6. **Security filters** — remove detected injection patterns, redact secrets
7. **Emit CompiledContext + receipt**

### Token Budget

Each tier has a configurable token budget. When the total exceeds the context window, items are evicted in priority order:

```
Priority (highest to lowest):
  Core Blocks (never evicted)  →  Working Memory  →  Episodic  →  Archival
```

Within a tier, lowest-confidence items are evicted first.

### Context Receipts

Every compiled context generates a receipt recording:
- Which blocks and memory items were included
- Which items were excluded and why (budget, TTL, confidence)
- Token estimates per tier
- The compiled context ID (for tracing which context produced which response)

---

## Memory Security

### Write Gates

Before any commit is finalized, write gates enforce:

| Gate | Purpose |
|------|---------|
| **Block allowlist** | Only permitted blocks can be written by the agent |
| **Evidence requirement** | Core:human edits require provenance from a user message |
| **Quarantine-by-default** | New core edits go to quarantine unless explicitly safe |
| **Confidence floor** | Below-floor writes go to archival only, never core |
| **Secret scrubbing** | Detected API keys, tokens, and credentials are blocked |

### Memory Exclusions

- The **Soul is never stored in memory** — memory references Soul version numbers, never Soul content. This prevents memory poisoning from corrupting governance.
- **PII is redacted** before storage via the local model
- **Secrets are never persisted** in any memory tier

### Poisoning Defense

Memory poisoning (injecting persistent malicious instructions) is defended by:
1. Input sanitization before memory writes
2. Quarantine for risky content
3. Confidence scoring and decay
4. Commit-based rollback for recovery
5. Provenance tracking for attribution

---

## Maintenance Jobs

The scheduler runs automated memory maintenance:

| Job | Schedule | Description |
|-----|----------|-------------|
| `memory_compact_working` | Hourly | Remove expired items, summarize long threads |
| `memory_decay_archival` | Daily (3 AM) | Reduce confidence over time unless reinforced |
| `memory_summarize_episodic` | Daily | Write session summaries, extract notable events |
| `memory_integrity_audit` | Daily | Verify commits have receipts, blocks within budget |

Each job emits receipts: `memory_job_run`, `memory_job_failed`, or `memory_job_skipped`.

---

## API Reference

| Method | Path | Auth | Description |
|--------|------|------|-------------|
| GET | `/memory/status` | None | Tier sizes, block counts, quarantine depth |
| GET | `/memory/core` | None | Current core blocks |
| GET | `/memory/search` | None | Search across tiers (query, tier filter, tags) |
| POST | `/memory/edit` | Bearer | Submit a governed memory edit |
| POST | `/memory/compile` | None | Compile context for a given objective |
| GET | `/memory/quarantine` | None | List quarantined items |
| POST | `/memory/quarantine/{id}/approve` | Bearer | Approve quarantined item |
| POST | `/memory/rollback/{commit_id}` | Bearer | Roll back to a previous commit |

---

## Feature Flag

```ini
FEATURE_MEMORY_VNEXT=true|false    # Default: false
```

When disabled, Lancelot falls back to basic context management (conversation history only). The system boots and functions normally without Memory vNext — it just doesn't have structured memory.

---

## Practical Guidance

### Inspecting Memory State

- **War Room → Memory panel**: View core blocks, tier sizes, quarantine queue, recent commits
- **API**: `GET /memory/status` for a quick overview, `GET /memory/core` for current core blocks

### Approving Quarantined Edits

Check the quarantine queue regularly (War Room Memory panel or `GET /memory/quarantine`). Each item shows what the agent wanted to write, why it was quarantined, and where the data came from. Approve items that are accurate; reject items that look wrong or suspicious.

### Rolling Back a Bad Edit

If a memory edit causes problems:
1. Find the commit ID in the War Room commit history or in the receipt
2. `POST /memory/rollback/{commit_id}` with your Bearer token
3. Verify the rollback via `GET /memory/core`

The rollback restores the exact state before that commit. All subsequent commits that depended on the rolled-back data may also need review.
