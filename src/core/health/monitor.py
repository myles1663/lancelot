"""
Health Monitor — background loop and snapshot computation (Prompt 10 / C3-C5).

Runs periodic health checks and caches the latest HealthSnapshot.
Emits receipts on state transitions.

Public API:
    HealthMonitor(check_fns, interval_s)
    start_monitor()       — start background loop
    stop_monitor()        — stop background loop
    compute_snapshot()    → HealthSnapshot
    latest_snapshot       → HealthSnapshot (cached)
    receipts              → list[dict]
"""

from __future__ import annotations

import logging
import threading
import time
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any, Callable, Dict, List, Optional

from src.core.health.types import HealthSnapshot

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Check function protocol
# ---------------------------------------------------------------------------

@dataclass
class HealthCheck:
    """A single health check definition."""
    name: str
    check_fn: Callable[[], bool]
    degraded_reason: str = ""


# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------

class HealthMonitor:
    """Background health monitor with snapshot caching and receipts."""

    def __init__(
        self,
        checks: Optional[List[HealthCheck]] = None,
        interval_s: float = 30.0,
    ):
        self._checks = checks or []
        self._interval_s = interval_s
        self._snapshot = HealthSnapshot()
        self._previous_ready: Optional[bool] = None
        self._receipts: List[Dict[str, Any]] = []
        self._running = False
        self._thread: Optional[threading.Thread] = None

    @property
    def latest_snapshot(self) -> HealthSnapshot:
        """Return the most recently computed health snapshot."""
        return self._snapshot

    @property
    def receipts(self) -> List[Dict[str, Any]]:
        """All receipt events generated by this monitor."""
        return list(self._receipts)

    def _emit_receipt(self, event: str, **kwargs: Any) -> Dict[str, Any]:
        """Record a receipt event."""
        receipt = {
            "event": event,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            **kwargs,
        }
        self._receipts.append(receipt)
        logger.info("%s: %s", event, kwargs)
        return receipt

    def compute_snapshot(self) -> HealthSnapshot:
        """Run all health checks and produce a HealthSnapshot.

        This is the core computation — can be called directly for testing.
        """
        degraded_reasons: List[str] = []
        results: Dict[str, bool] = {}

        for check in self._checks:
            try:
                ok = check.check_fn()
                results[check.name] = ok
                if not ok:
                    reason = check.degraded_reason or f"{check.name} check failed"
                    degraded_reasons.append(reason)
            except Exception as exc:
                results[check.name] = False
                degraded_reasons.append(f"{check.name}: {exc}")

        ready = len(degraded_reasons) == 0

        snapshot = HealthSnapshot(
            ready=ready,
            onboarding_state=(
                ("READY" if results["onboarding_ready"] else "NOT_READY")
                if "onboarding_ready" in results
                else "UNKNOWN"
            ),
            local_llm_ready=results.get("local_llm", False),
            scheduler_running=results.get("scheduler", False),
            last_health_tick_at=datetime.now(timezone.utc).isoformat(),
            degraded_reasons=degraded_reasons,
        )

        # Emit receipts on state transitions
        if self._previous_ready is not None:
            if ready and not self._previous_ready:
                self._emit_receipt("health_recovered")
            elif not ready and self._previous_ready:
                self._emit_receipt("health_degraded", reasons=degraded_reasons)
        elif ready:
            self._emit_receipt("health_ok")
        else:
            self._emit_receipt("health_degraded", reasons=degraded_reasons)

        self._previous_ready = ready
        self._snapshot = snapshot
        return snapshot

    def start_monitor(self) -> None:
        """Start the background health monitoring loop."""
        if self._running:
            return
        self._running = True
        self._thread = threading.Thread(
            target=self._loop, daemon=True, name="health-monitor"
        )
        self._thread.start()
        logger.info("Health monitor started (interval=%ss)", self._interval_s)

    def stop_monitor(self) -> None:
        """Stop the background health monitoring loop."""
        self._running = False
        if self._thread is not None:
            self._thread.join(timeout=self._interval_s + 1)
            self._thread = None
        logger.info("Health monitor stopped")

    def _loop(self) -> None:
        """Background loop that periodically computes snapshots."""
        while self._running:
            try:
                self.compute_snapshot()
            except Exception:
                logger.exception("Health monitor tick failed")
            time.sleep(self._interval_s)
